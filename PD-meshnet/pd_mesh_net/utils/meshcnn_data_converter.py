"""This script was used to generate the version of the COSEG dataset
corresponding to the one used in MeshCNN.
"""
import argparse
import glob
import numpy as np
import os
import pymesh
import sys

from pd_mesh_net.utils.colors import SegmentationColors


class SegmentationDatasetConverter():
    r"""Converts samples from a segmentation dataset from the format used in
    MeshCNN (cached numpy data, class labels assigned to edges) to mesh files
    and label files, where class labels are assigned to faces.

    Args:
        main_data_folder (str): Folder containing the four subfolders `train`,
            `test`, `seg` and `sseg` (not used). It is expected that the two
            subfolders `train` and `test` both contain a subfolder `cache`,
            where one can find the numpy-cached files ('.npz' extension) with
            the mesh data in the format generated by MeshCNN. It is also
            expected that the `seg` subfolder contains the files ('.eseg'
            extension) with the per-edge class labels in the format generated by
            MeshCNN.
        output_folder (str): Folder where the output files should be saved. The
            folder will include the mesh files separated in two subfolders
            `train` and `test`, and the label files in a subfolder `seg`.
        save_color_in_meshes (bool, optional): If True, the faces in the mesh
            files are colored according to the class labels associated to them.
            (default: :obj:`False`)

    Attributes:
        None.
    """

    def __init__(self,
                 main_data_folder,
                 output_folder,
                 save_color_in_meshes=False):
        # Create the output folders if non-existent.
        self.__output_folder = output_folder
        if (not os.path.exists(output_folder)):
            os.makedirs(output_folder)
        output_train_meshes_folder = os.path.join(output_folder, 'train')
        if (not os.path.exists(output_train_meshes_folder)):
            os.makedirs(output_train_meshes_folder)
        output_test_meshes_folder = os.path.join(output_folder, 'test')
        if (not os.path.exists(output_test_meshes_folder)):
            os.makedirs(output_test_meshes_folder)
        output_class_labels_folder = os.path.join(output_folder, 'seg')
        if (not os.path.exists(output_class_labels_folder)):
            os.makedirs(output_class_labels_folder)
        # Allow to call recursive function the needed number of times.
        sys.setrecursionlimit(5000)
        # By default, in the rare case a face has three edges with three
        # different class labels, the face is momentarily skipped to see whether
        # assigning class labels to the other faces and updating the edges
        # labels solves the ambiguity. If this does not happen, a class label is
        # randomly selected among the three.
        self.__force_label_assignment_to_ambiguous_faces = False
        # Find all the input data.
        segmentation_data_folder = os.path.join(main_data_folder, 'seg')
        for self.__split in ['train', 'test']:
            mesh_data_folder = os.path.join(main_data_folder, self.__split,
                                            'cache')
            # - Only take non-augmented version of the mesh.
            mesh_data_filenames = glob.glob(
                os.path.join(mesh_data_folder, "*_000.npz"))

            for mesh_data_filename in mesh_data_filenames:
                self.__base_filename_with_aug = os.path.basename(
                    mesh_data_filename).rsplit('.', 1)[0]
                self.__base_filename = self.__base_filename_with_aug.rsplit(
                    '_', 1)[0]
                segmentation_data_filename = os.path.join(
                    segmentation_data_folder, f"{self.__base_filename}.eseg")
                print(f"** Processing mesh {self.__base_filename}")
                self.__segmentation_data_filename = segmentation_data_filename
                self.__save_color_in_meshes = save_color_in_meshes
                # Load mesh data and per-edge class labels.
                mesh_data = np.load(mesh_data_filename, allow_pickle=True)
                # - The class labels start from 1; we remap them so that they
                #   start from 0. This way they can be used directly with the
                #   PyTorch implementation of cross-entropy loss, without
                #   further changes.
                self.__segmentation_data = np.loadtxt(
                    open(segmentation_data_filename, 'r'), dtype='long') - 1
                # Load vertices.
                self.__vertices = mesh_data['vs']
                self.__num_vertices = self.__vertices.shape[0]
                # Edges.
                self.__edges = mesh_data['edges']
                self.__gemm_edges = mesh_data['gemm_edges']
                self.__num_edges = self.__edges.shape[0]
                self.__found_boundary_edge = False
                # - Make edges directed.
                self.__edges = np.vstack([self.__edges, self.__edges[:, ::-1]])
                self.__gemm_edges = np.vstack(
                    [self.__gemm_edges, self.__gemm_edges])
                self.__segmentation_data = np.hstack(
                    [self.__segmentation_data, self.__segmentation_data])

                self.__halfedge_to_halfedge_idx = {}
                self.__halfedge_to_face_idx = {}
                self.__face_to_face_idx = {}
                for halfedge_idx, halfedge in enumerate(self.__edges):
                    self.__halfedge_to_halfedge_idx[(
                        halfedge[0], halfedge[1])] = halfedge_idx

                # Create faces.
                self.__was_halfedge_used = np.zeros([self.__num_edges * 2],
                                                    dtype=np.bool)
                self.__faces = np.empty([2 * self.__num_edges, 3])
                # - Stores the class label of each face, obtained by taking the
                #   most frequent class label of those assigned to the face
                #   edges.
                self.__class_label_per_face = [None] * len(self.__faces)
                self.__color_per_class_label = SegmentationColors.colors
                halfedges_to_find = []
                for halfedge in self.__edges:
                    self.__halfedge_to_face_idx[tuple(halfedge.tolist())] = None
                    halfedges_to_find.append(halfedge.tolist())
                # - Start with any half-edge.
                self.__num_faces = 0
                num_connected_components = 0
                while (len(halfedges_to_find) > 0):
                    old_halfedges_to_find = halfedges_to_find.copy()
                    num_connected_components += 1
                    first_halfedge = halfedges_to_find[0]
                    self.__form_faces_with_halfedge(first_halfedge[0],
                                                    first_halfedge[1])
                    # Check that all edges were added to a face.
                    all_faces_found = True
                    halfedges_to_find = []
                    for halfedge in self.__edges:
                        if (self.__halfedge_to_face_idx[tuple(
                                halfedge.tolist())] is None):
                            all_faces_found = False
                            halfedges_to_find.append(halfedge.tolist())
                    if (halfedges_to_find == old_halfedges_to_find):
                        # The fact that no new half-edges get added to the mesh
                        # may be caused by:
                        # - Faces that cannot have a class label assigned
                        #   because of ambiguity.
                        # - Half-edges that cannot be assigned to any face
                        #   because the associated edge is boundary.
                        if (not self.__force_label_assignment_to_ambiguous_faces
                           ):
                            # - Try one more iteration in which ambiguous face
                            #   are forced to be labelled.
                            self.__force_label_assignment_to_ambiguous_faces = (
                                True)
                            num_connected_components -= 1
                        else:
                            assert (self.__found_boundary_edge), (
                                "Something is wrong with mesh "
                                f"{self.__base_filename}. num_vertices = "
                                f"{self.__num_vertices}, num_edges = "
                                f"{self.__num_edges}, num_faces = "
                                f"{self.__num_faces}, halfedges_to_find = "
                                f"{halfedges_to_find}.")
                            break
                    if (not all_faces_found):
                        print("Not all faces were found.")

                if (num_connected_components == 1):
                    if (not self.__found_boundary_edge):
                        # The mesh is watertight, Euler's formula must hold.
                        genus = (self.__num_edges - self.__num_vertices -
                                 self.__num_faces) // 2 + 1
                        if (genus != 0):
                            print(f"\033[93mDoes mesh {self.__base_filename} "
                                  f"have genus {genus}?\033[0m")
                else:
                    print(f"Mesh {self.__base_filename} has "
                          f"{num_connected_components} connected components.")
                self.__faces = self.__faces[:self.__num_faces]
                self.__class_label_per_face = (
                    self.__class_label_per_face[:self.__num_faces])
                # Save mesh.
                self.__save_mesh()

    def __form_faces_with_halfedge(self, vertex_a, vertex_b, verbose=False):
        r"""Recursive function. Constructs the face with the input half-edge,
        adds it to the mesh, and reiterates on the neighboring faces.

        Args:
            vertex_a, vertex_b (int): Indices of the two mesh vertices a and b
                forming the half-edge a->b, that belongs to the face that should
                be added to the mesh.
            verbose (bool, optional): If True, shows verbose prints.
        
        Returns:
            None.
        """
        # Form faces a->b->c->a.
        # There are up to two faces per each edge (one for each half-edge,
        # unless the edge is boundary).
        for halfedge_idx in range(2):
            idx_halfedge_ab = self.__halfedge_to_halfedge_idx[(vertex_a,
                                                               vertex_b)]
            edge_ab = set(self.__edges[idx_halfedge_ab])
            idx_halfedge_bc = self.__gemm_edges[idx_halfedge_ab,
                                                2 * halfedge_idx]
            if (idx_halfedge_bc == -1):
                # Boundary edge. -> No face.
                self.__found_boundary_edge = True
                continue
            edge_bc = set(self.__edges[idx_halfedge_bc])
            vertex_b = edge_ab & edge_bc
            assert (len(vertex_b) == 1)
            vertex_a = list(edge_ab - vertex_b)[0]
            vertex_c = list(edge_bc - vertex_b)[0]
            vertex_b = list(vertex_b)[0]
            if (verbose):
                print(f"* Processing edge {vertex_a}->{vertex_b}")
            idx_halfedge_ab = self.__halfedge_to_halfedge_idx[(vertex_a,
                                                               vertex_b)]
            idx_halfedge_bc = self.__halfedge_to_halfedge_idx[(vertex_b,
                                                               vertex_c)]
            if (self.__was_halfedge_used[idx_halfedge_ab]):
                if (verbose):
                    face_containing_ab = self.__halfedge_to_face_idx[(vertex_a,
                                                                      vertex_b)]
                    print(
                        f"Edge a->b ({vertex_a}->{vertex_b}) was already used "
                        f"in face {face_containing_ab} ("
                        f"{self.__faces[face_containing_ab]}).")
                continue

            assert (not self.__was_halfedge_used[idx_halfedge_bc])
            idx_halfedge_ca = self.__gemm_edges[idx_halfedge_ab,
                                                2 * halfedge_idx + 1]
            edge_ca = set(self.__edges[idx_halfedge_ca])
            assert (vertex_a in edge_ca and vertex_c in edge_ca)
            idx_halfedge_ca = self.__halfedge_to_halfedge_idx[(vertex_c,
                                                               vertex_a)]

            were_same_halfedges_used_already = (
                self.__was_halfedge_used[idx_halfedge_ab] or
                self.__was_halfedge_used[idx_halfedge_bc] or
                self.__was_halfedge_used[idx_halfedge_ca])
            # Check that the opposite face was not inserted.
            was_opposite_face_inserted = (
                vertex_a, vertex_c, vertex_b) in self.__face_to_face_idx or (
                    vertex_c, vertex_b,
                    vertex_a) in self.__face_to_face_idx or (
                        vertex_b, vertex_a, vertex_c) in self.__face_to_face_idx
            if (were_same_halfedges_used_already or was_opposite_face_inserted):
                continue
            # Add face, if it is possible to determine its class label.
            face_idx = self.__num_faces
            assert (self.__class_label_per_face[face_idx] is None)
            class_labels_in_face = [
                self.__segmentation_data[idx_halfedge_ab],
                self.__segmentation_data[idx_halfedge_bc],
                self.__segmentation_data[idx_halfedge_ca]
            ]
            # - Find the most frequent label in the three associated to the
            #   edges.
            if (len(set(class_labels_in_face)) == 3):
                if (self.__force_label_assignment_to_ambiguous_faces):
                    # - Select arbitrarily the class label of the first edge.
                    class_label = self.__segmentation_data[idx_halfedge_ab]
                    self.__class_label_per_face[face_idx] = class_label
                    self.__segmentation_data[idx_halfedge_ab] = class_label
                    self.__segmentation_data[idx_halfedge_bc] = class_label
                    self.__segmentation_data[idx_halfedge_ca] = class_label
                    print("\033[91mNote: arbitrarily assigned class label of "
                          f"edge {idx_halfedge_ab} to face {face_idx}, as the "
                          f"latter has 3 edges (indices {idx_halfedge_ab}, "
                          f"{idx_halfedge_bc} and {idx_halfedge_ca}) with "
                          "different class labels.\033[0m")
                else:
                    print(
                        "\033[93mUnable to assign a class label to face "
                        f"{face_idx}, as it has 3 edges (indices "
                        f"{idx_halfedge_ab}, {idx_halfedge_bc} and "
                        f"{idx_halfedge_ca}) with different class labels. Will "
                        "try again later.\033[0m")
                    continue
            else:
                # - Select the class label that is shared by most edges in the
                #   face.
                for class_label in set(class_labels_in_face):
                    if (class_labels_in_face.count(class_label) > 1):
                        self.__class_label_per_face[face_idx] = class_label
                        self.__segmentation_data[idx_halfedge_ab] = class_label
                        self.__segmentation_data[idx_halfedge_bc] = class_label
                        self.__segmentation_data[idx_halfedge_ca] = class_label
                        break

            self.__faces[face_idx] = [vertex_a, vertex_b, vertex_c]
            self.__was_halfedge_used[idx_halfedge_ab] = True
            self.__was_halfedge_used[idx_halfedge_bc] = True
            self.__was_halfedge_used[idx_halfedge_ca] = True
            self.__halfedge_to_face_idx[(vertex_a, vertex_b)] = face_idx
            self.__halfedge_to_face_idx[(vertex_b, vertex_c)] = face_idx
            self.__halfedge_to_face_idx[(vertex_c, vertex_a)] = face_idx
            self.__face_to_face_idx[(vertex_a, vertex_b, vertex_c)] = face_idx

            self.__num_faces += 1
            # Add neighboring faces.
            self.__form_faces_with_halfedge(vertex_c, vertex_b, verbose=verbose)
            self.__form_faces_with_halfedge(vertex_a, vertex_c, verbose=verbose)

    def __save_mesh(self):
        r"""Forms the mesh with the faces created by calling
        `form_faces_with_halfedge` and saves it and the per-face class labels to
        disk.

        Args:
            None.
        
        Returns:
            None.
        """
        # Form mesh.
        self.__mesh = pymesh.form_mesh(self.__vertices, self.__faces)
        # Optionally add colors to the mesh.
        if (self.__save_color_in_meshes):
            self.__mesh.add_attribute("face_blue")
            self.__mesh.add_attribute("face_green")
            self.__mesh.add_attribute("face_red")
            self.__mesh.add_attribute("face_alpha")
            blue_values = np.zeros([self.__mesh.num_faces])
            green_values = np.zeros([self.__mesh.num_faces])
            red_values = np.zeros([self.__mesh.num_faces])
            alpha_values = np.zeros([self.__mesh.num_faces], dtype=np.float64)
            assert (self.__mesh.num_faces == self.__num_faces)
            for face_idx in range(self.__num_faces):
                face_class_label = self.__class_label_per_face[face_idx]
                color_per_face = self.__color_per_class_label[face_class_label]
                blue_values[face_idx] = color_per_face[0]
                green_values[face_idx] = color_per_face[1]
                red_values[face_idx] = color_per_face[2]
            self.__mesh.set_attribute("face_blue", blue_values)
            self.__mesh.set_attribute("face_green", green_values)
            self.__mesh.set_attribute("face_red", red_values)
            self.__mesh.set_attribute("face_alpha", alpha_values)
        # Save mesh.
        output_mesh_path = os.path.join(self.__output_folder, self.__split,
                                        f"{self.__base_filename}.ply")
        print(f"Saving mesh at {output_mesh_path}.")
        if (self.__save_color_in_meshes):
            pymesh.save_mesh(output_mesh_path,
                             self.__mesh,
                             "face_blue",
                             "face_green",
                             "face_red",
                             "face_alpha",
                             ascii=True)
        else:
            pymesh.save_mesh(output_mesh_path, self.__mesh, ascii=True)
        # Save per-face labels.
        output_class_labels_path = os.path.join(self.__output_folder, 'seg',
                                                f"{self.__base_filename}.eseg")
        np.savetxt(output_class_labels_path, self.__class_label_per_face, '%d')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--i',
                        '--main_data_folder',
                        type=str,
                        dest='main_data_folder',
                        required=True)
    parser.add_argument('--o',
                        '--output_folder',
                        type=str,
                        dest='output_folder',
                        required=True)
    args = parser.parse_args()
    face_former = SegmentationDatasetConverter(
        main_data_folder=args.main_data_folder,
        output_folder=args.output_folder,
        save_color_in_meshes=True)
